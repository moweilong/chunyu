// Code generated by gowebx, DO AVOID EDIT.
package tokencache

import (
	"context"
	"fmt"
	"time"

	"github.com/moweilong/chunyu/domain/token"
	"github.com/moweilong/chunyu/pkg/orm"
	"gorm.io/gorm"
)

// 若不需要实现缓存，可以注释
var _ token.TokenStorer = (*Token)(nil)

type Token Cache

// Expire implements token.TokenStorer.
func (c *Token) Expire(ctx context.Context, scope string, userID string, reason string) ([]string, error) {
	keys, err := c.store.Token().Expire(ctx, scope, userID, reason)
	if err != nil {
		return keys, err
	}
	for _, key := range keys {
		c.token.Del(ctx, c.cacheKey(key))
	}
	return keys, nil
}

// DelAllForUser implements token.TokenStorer.
func (c *Token) DelAllForUser(ctx context.Context, scope string, userID string) ([]string, error) {
	keys, err := c.store.Token().DelAllForUser(ctx, scope, userID)
	if err != nil {
		return keys, err
	}
	for _, key := range keys {
		c.token.Del(ctx, c.cacheKey(key))
	}
	return keys, nil
}

func (c *Token) cacheKey(key any) string {
	return fmt.Sprintf("TOKEN:%v", key)
}

// DelExpired implements token.TokenStorer.
func (c *Token) DelExpired(ctx context.Context, before time.Time) ([]string, error) {
	ids, err := c.store.Token().DelExpired(ctx, before)
	if err != nil {
		return ids, err
	}
	for _, id := range ids {
		c.token.Del(ctx, c.cacheKey(id))
	}
	return ids, nil
}

// Find implements token.TokenStorer.
func (c *Token) Find(ctx context.Context, bs *[]*token.Token, page orm.Pager, opts ...orm.QueryOption) (int64, error) {
	return c.store.Token().Find(ctx, bs, page, opts...)
}

// Get implements token.TokenStorer.
// 注意: 若想走缓存，则 model 的 id 必传
// 条件查询无法缓存，此缓存仅为 ID 查询生效。
func (c *Token) Get(ctx context.Context, model *token.Token, opts ...orm.QueryOption) error {
	if key := model.CacheKey(); key != "" {
		if err := c.token.Get(ctx, c.cacheKey(model.CacheKey()), model); err == nil {
			return nil
		}
	}

	if err := c.store.Token().Get(ctx, model, opts...); err != nil {
		return err
	}
	c.token.SetNX(ctx, c.cacheKey(model.CacheKey()), model)
	return nil
}

// Add implements token.TokenStorer.
func (c *Token) Add(ctx context.Context, model *token.Token) error {
	if err := c.store.Token().Add(ctx, model); err != nil {
		return err
	}
	c.token.Set(ctx, c.cacheKey(model.CacheKey()), model)
	return nil
}

// Edit implements token.TokenStorer.
func (c *Token) Edit(ctx context.Context, model *token.Token, changeFn func(*token.Token), opts ...orm.QueryOption) error {
	if err := c.store.Token().Edit(ctx, model, changeFn, opts...); err != nil {
		return err
	}
	c.token.Set(ctx, c.cacheKey(model.CacheKey()), model)
	return nil
}

// Del implements token.TokenStorer.
func (c *Token) Del(ctx context.Context, model *token.Token, opts ...orm.QueryOption) error {
	if err := c.store.Token().Del(ctx, model, opts...); err != nil {
		return err
	}
	c.token.Del(ctx, c.cacheKey(model.CacheKey()))
	return nil
}

// Session 事务组合
func (c *Token) Session(ctx context.Context, changeFns ...func(*gorm.DB) error) error {
	// return c.store.Token().Session(ctx, changeFns...)
	return nil
}

// EditWithSession 修改事务
func (c *Token) EditWithSession(tx *gorm.DB, model *token.Token, changeFn func(b *token.Token) error, opts ...orm.QueryOption) error {
	//	if err := c.store.Token().EditWithSession(ctx,model, changeFn,opts...);err!=nil{
	// return err
	//	}
	//	c.token.Set(ctx, c.cacheKey(model.ID ),  model)
	return nil
}
