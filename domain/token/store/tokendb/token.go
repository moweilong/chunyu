// Code generated by gowebx, DO AVOID EDIT.
package tokendb

import (
	"context"
	"encoding/hex"
	"time"

	"github.com/moweilong/chunyu/domain/token"
	"github.com/moweilong/chunyu/pkg/orm"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

var _ token.TokenStorer = Token{}

// Token Related business namespaces
type Token DB

// Expire implements token.TokenStorer.
func (d Token) Expire(ctx context.Context, scope string, userID string, reason string) ([]string, error) {
	var expiredTokens []token.Token
	if err := d.db.WithContext(ctx).Clauses(clause.Returning{Columns: []clause.Column{{Name: "id"}, {Name: "hash"}}}).
		Where("scope = ? AND user_id = ? AND expired_at > ?", scope, userID, time.Now()).
		Model(&expiredTokens).Update("reason", reason).Error; err != nil {
		return nil, err
	}

	hashes := make([]string, len(expiredTokens))
	for i, t := range expiredTokens {
		hashes[i] = hex.EncodeToString(t.Hash)
	}
	return hashes, nil
}

// NewToken instance object
func NewToken(db *gorm.DB) Token {
	return Token{db: db}
}

// Find implements token.TokenStorer.
func (d Token) Find(ctx context.Context, bs *[]*token.Token, page orm.Pager, opts ...orm.QueryOption) (int64, error) {
	return orm.FindWithContext(ctx, d.db, bs, page, opts...)
}

// Get implements token.TokenStorer.
func (d Token) Get(ctx context.Context, model *token.Token, opts ...orm.QueryOption) error {
	return orm.FirstWithContext(ctx, d.db, model, opts...)
}

// Add implements token.TokenStorer.
func (d Token) Add(ctx context.Context, model *token.Token) error {
	return d.db.WithContext(ctx).Create(model).Error
}

// Edit implements token.TokenStorer.
func (d Token) Edit(ctx context.Context, model *token.Token, changeFn func(*token.Token), opts ...orm.QueryOption) error {
	return orm.UpdateWithContext(ctx, d.db, model, changeFn, opts...)
}

// Del implements token.TokenStorer.
func (d Token) Del(ctx context.Context, model *token.Token, opts ...orm.QueryOption) error {
	return orm.DeleteWithContext(ctx, d.db, model, opts...)
}

// Session 事务组合
func (d Token) Session(ctx context.Context, changeFns ...func(*gorm.DB) error) error {
	return d.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
		for _, fn := range changeFns {
			if err := fn(tx); err != nil {
				return err
			}
		}
		return nil
	})
}

// EditWithSession 修改事务
func (d Token) EditWithSession(tx *gorm.DB, model *token.Token, changeFn func(b *token.Token) error, opts ...orm.QueryOption) error {
	return orm.UpdateWithSession(tx, model, changeFn, opts...)
}

// DelAllForUser 删除用户的 token
func (d Token) DelAllForUser(ctx context.Context, scope, userID string) ([]string, error) {
	var deletedTokens []token.Token
	result := d.db.WithContext(ctx).Clauses(clause.Returning{Columns: []clause.Column{{Name: "id"}, {Name: "hash"}}}).
		Where("scope = ? AND user_id = ?", scope, userID).Delete(&deletedTokens)
	if result.Error != nil {
		return nil, result.Error
	}

	hashes := make([]string, len(deletedTokens))
	for i, t := range deletedTokens {
		hashes[i] = hex.EncodeToString(t.Hash)
	}
	return hashes, nil
}

// DelExpired 删除过期的 token
func (d Token) DelExpired(ctx context.Context, before time.Time) ([]string, error) {
	var deletedTokens []token.Token
	result := d.db.WithContext(ctx).Clauses(clause.Returning{Columns: []clause.Column{{Name: "id"}, {Name: "hash"}}}).
		Where("expired_at < ?", before).Delete(&deletedTokens)
	if result.Error != nil {
		return nil, result.Error
	}

	hashes := make([]string, len(deletedTokens))
	for i, t := range deletedTokens {
		hashes[i] = hex.EncodeToString(t.Hash)
	}
	return hashes, nil
}
